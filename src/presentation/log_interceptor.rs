//! Log Interceptor - Captures actual game log messages for UI display
//!
//! This module intercepts log messages generated by the game systems
//! and converts them into UI-displayable messages. It filters and categorizes
//! log messages based on their content and log level.

use crate::domain::services::game_log_service::{GameLogService, GameLogType};
use crate::infrastructure::time::TimeService;
use bevy::prelude::*;
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};

/// Plugin for log interception functionality
pub struct LogInterceptorPlugin;

impl Plugin for LogInterceptorPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<LogInterceptorState>()
            .add_systems(Update, process_intercepted_logs);
    }
}

/// Resource to store intercepted log messages
#[derive(Resource)]
pub struct LogInterceptorState {
    /// Queue of intercepted messages
    pub intercepted_messages: VecDeque<InterceptedLogMessage>,
    /// Maximum number of messages to keep
    pub max_messages: usize,
}

/// A log message that was intercepted from the logging system
#[derive(Debug, Clone)]
pub struct InterceptedLogMessage {
    pub message: String,
    pub level: String,
    pub target: String,
    pub timestamp: u64,
}

impl Default for LogInterceptorState {
    fn default() -> Self {
        Self {
            intercepted_messages: VecDeque::new(),
            max_messages: 100,
        }
    }
}

/// System that processes intercepted log messages and adds them to the game log
fn process_intercepted_logs(
    mut interceptor_state: ResMut<LogInterceptorState>,
    mut game_log: ResMut<GameLogService>,
) {
    // Process any intercepted messages
    while let Some(intercepted) = interceptor_state.intercepted_messages.pop_front() {
        if let Some((log_type, formatted_message)) = categorize_log_message(&intercepted) {
            game_log.log_message(formatted_message, log_type);
        }
    }
}

/// Categorize a log message based on its content and convert to game log format
fn categorize_log_message(intercepted: &InterceptedLogMessage) -> Option<(GameLogType, String)> {
    let message = &intercepted.message;
    let level = &intercepted.level;

    // Filter out unwanted messages
    if should_ignore_message(message) {
        return None;
    }

    // Determine log type and clean up the message
    let (log_type, clean_message) = match level.as_str() {
        "ERROR" => (GameLogType::Critical, clean_message_text(message)),
        "WARN" => {
            if message.contains("Movement failed") || message.contains("Not enough") {
                (GameLogType::Warning, clean_message_text(message))
            } else {
                (GameLogType::Warning, clean_message_text(message))
            }
        }
        "INFO" => {
            if message.contains("Player moved") || message.contains("Attempting") {
                (GameLogType::Movement, clean_message_text(message))
            } else if message.contains("Rest")
                || message.contains("Night")
                || message.contains("Dawn")
            {
                (GameLogType::Rest, clean_message_text(message))
            } else if message.contains("Roll") || message.contains("Rolled") {
                (GameLogType::System, clean_message_text(message))
            } else if message.contains("Event Triggered") || message.contains("phenomenon") {
                (GameLogType::Event, clean_message_text(message))
            } else if message.contains("Resources") || message.contains("points") {
                (GameLogType::Resources, clean_message_text(message))
            } else if message.contains("Explored") || message.contains("Updated map") {
                (GameLogType::Discovery, clean_message_text(message))
            } else if message.contains("exhausted") || message.contains("drowsy") {
                (GameLogType::System, clean_message_text(message))
            } else {
                (GameLogType::Narrative, clean_message_text(message))
            }
        }
        _ => (GameLogType::System, clean_message_text(message)),
    };

    Some((log_type, clean_message))
}

/// Clean up log message text by removing emojis and formatting
fn clean_message_text(message: &str) -> String {
    message
        // Remove common emoji patterns
        .chars()
        .filter(|c| !is_emoji(*c))
        // Remove extra whitespace
        .collect::<String>()
        .split_whitespace()
        .collect::<Vec<&str>>()
        .join(" ")
        // Remove log prefixes
        .replace("space_looter::", "")
        .replace("space_looter: ", "")
        .trim()
        .to_string()
}

/// Check if a character is likely an emoji
fn is_emoji(c: char) -> bool {
    matches!(c as u32,
        0x1F600..=0x1F64F | // Emoticons
        0x1F300..=0x1F5FF | // Misc Symbols and Pictographs
        0x1F680..=0x1F6FF | // Transport and Map
        0x1F1E6..=0x1F1FF | // Regional indicator symbols
        0x2600..=0x26FF |   // Misc symbols
        0x2700..=0x27BF |   // Dingbats
        0xFE0E..=0xFE0F |   // Variation selectors
        0x1F900..=0x1F9FF | // Supplemental Symbols and Pictographs
        0x1F018..=0x1F270 | // Various symbols
        0x238C..=0x2454 |   // Misc symbols
        0x20D0..=0x20FF     // Combining marks
    )
}

/// Determine if a log message should be ignored
fn should_ignore_message(message: &str) -> bool {
    // Ignore debug/trace messages
    message.contains("DEBUG") ||
    message.contains("TRACE") ||
    // Ignore system initialization messages
    message.contains("Initializing") ||
    message.contains("initialized") ||
    // Ignore renderer internal messages
    message.contains("wgpu") ||
    message.contains("winit") ||
    // Ignore other technical messages
    message.contains("AssetServer") ||
    message.len() < 5 // Too short to be meaningful
}

/// Initialize log interception
pub fn setup_log_interception(interceptor_state: Arc<Mutex<LogInterceptorState>>) {
    // This would be called during app setup to configure log interception
    // Implementation would depend on the logging framework being used
}

/// Add a log message to the interceptor queue
impl LogInterceptorState {
    pub fn add_intercepted_message(&mut self, message: String, level: String, target: String) {
        let intercepted = InterceptedLogMessage {
            message,
            level,
            target,
            timestamp: TimeService::now_millis().unwrap_or(0),
        };

        self.intercepted_messages.push_back(intercepted);

        // Keep only recent messages
        while self.intercepted_messages.len() > self.max_messages {
            self.intercepted_messages.pop_front();
        }
    }
}

/// Helper function to manually add game events to the log
pub fn log_game_event(
    mut game_log: ResMut<GameLogService>,
    message: String,
    event_type: GameEventType,
) {
    let log_type = match event_type {
        GameEventType::Movement => GameLogType::Movement,
        GameEventType::Rest => GameLogType::Rest,
        GameEventType::Discovery => GameLogType::Discovery,
        GameEventType::Resources => GameLogType::Resources,
        GameEventType::Event => GameLogType::Event,
        GameEventType::Warning => GameLogType::Warning,
        GameEventType::Critical => GameLogType::Critical,
        GameEventType::System => GameLogType::System,
    };

    game_log.log_message(message, log_type);
}

/// Types of game events that can be logged
#[derive(Debug, Clone)]
pub enum GameEventType {
    Movement,
    Rest,
    Discovery,
    Resources,
    Event,
    Warning,
    Critical,
    System,
}

/// Create formatted log messages for common game events
impl LogInterceptorState {
    pub fn format_movement_message(
        from_x: i32,
        from_y: i32,
        to_x: i32,
        to_y: i32,
        success: bool,
    ) -> String {
        if success {
            format!(
                "Moved from ({}, {}) to ({}, {})",
                from_x, from_y, to_x, to_y
            )
        } else {
            format!(
                "Failed to move to ({}, {}) - insufficient resources",
                to_x, to_y
            )
        }
    }

    pub fn format_rest_message(night_event: &str, rest_quality: &str, roll: u8) -> String {
        format!(
            "Night Roll: {} - {} | Rest Quality: {}",
            roll, night_event, rest_quality
        )
    }

    pub fn format_discovery_message(discovery: &str, x: i32, y: i32) -> String {
        format!("Discovered {} at ({}, {})", discovery, x, y)
    }

    pub fn format_resource_message(resource_type: &str, amount: i32, reason: &str) -> String {
        if amount > 0 {
            format!("Gained {} {} from {}", amount, resource_type, reason)
        } else {
            format!("Lost {} {} from {}", -amount, resource_type, reason)
        }
    }

    pub fn format_dice_message(
        base_roll: u8,
        modifier: i8,
        final_result: u8,
        outcome: &str,
    ) -> String {
        let modifier_text = if modifier >= 0 {
            format!("+{}", modifier)
        } else {
            modifier.to_string()
        };
        format!(
            "Rolled {} {} = {} - Outcome: {}",
            base_roll, modifier_text, final_result, outcome
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_categorization() {
        let intercepted = InterceptedLogMessage {
            message: "Player moved to position: Position3D { x: -9, y: -2, z: 0 }".to_string(),
            level: "INFO".to_string(),
            target: "space_looter".to_string(),
            timestamp: TimeService::now_millis().unwrap_or(0),
        };

        let result = categorize_log_message(&intercepted);
        assert!(result.is_some());
        let (log_type, _) = result.unwrap();
        assert_eq!(log_type, GameLogType::Movement);
    }

    #[test]
    fn test_message_cleaning() {
        let dirty_message = "üé≤ Player moved to new location! üó∫Ô∏è";
        let clean = clean_message_text(dirty_message);
        assert!(!clean.contains("üé≤"));
        assert!(!clean.contains("üó∫Ô∏è"));
        assert!(clean.contains("Player moved to new location"));
    }

    #[test]
    fn test_ignore_messages() {
        assert!(should_ignore_message("DEBUG: some debug info"));
        assert!(should_ignore_message("Initializing system"));
        assert!(!should_ignore_message("Player moved successfully"));
    }

    #[test]
    fn test_emoji_detection() {
        assert!(is_emoji('üé≤'));
        assert!(is_emoji('üó∫'));
        assert!(!is_emoji('A'));
        assert!(!is_emoji('1'));
    }

    #[test]
    fn test_formatted_messages() {
        let movement = LogInterceptorState::format_movement_message(0, 0, 1, 0, true);
        assert!(movement.contains("Moved from (0, 0) to (1, 0)"));

        let rest = LogInterceptorState::format_rest_message("Peaceful Rest", "Normal", 12);
        assert!(rest.contains("Roll: 12"));
        assert!(rest.contains("Peaceful Rest"));
    }
}
